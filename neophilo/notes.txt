Chaque philo doit etre un thread a part entiere
Pour cela, on va creer un tableau de threads de types pthread_t
Chacun va representer un philo.
On va devoir eviter les data races. Il faut donc determiner les donnees
communes qui devront etre accessibles et MODIFIABLES pour chacun 
des philos, et proteger celles-ci via des mutex.
De plus, on va checker dans le main thread quaucun des philos n'est mort
et des qu'un philo meurt, on liberera la memoire.

DONNEES PARTAGEES:
typedef struct s_shared_data{
	int		total_philos;
	int		die_timer;
	int		eat_timer;
	int		slp_timer;
	int		max_meals;
	double	init_time;			//temps a l'init
	bool	forks[MAX_PHILOS];	//tableau de fourchettes: 0 si la fourchette est libre, 1 sinon
	bool	death_bool;			//Booleen qui vaut 0 si aucun philo n'est mort, 1 sinon
	pthread_mutex_t	mut_fork[MAX_PHILOS];	//tableau de mutex pour proteger les forks
	pthread_mutex_t	print;		//mutex sur le print pour eviter que 2 philos print en meme temps
	pthread_mutex_t	keeper;		
	pthread_mutex_t	*death;		mutex sur la modification de death_bool (eviter les data races si 2 philos meurent en meme temps)
}	t_shared_data;

Ici, toutes les variables qui seront propres a chaque philo
typedef struct s_philo{
	t_shared_data	shared;
	int				id;
	int				eaten_meals;
	bool			r_fork;
	bool			l_fork;
	bool			dead;
	double			last_meal;
	pthread_mutex_t	death;
}	t_philo;

Chaque philo va contenir un booleen sur ses fourchettes droites et gauches
